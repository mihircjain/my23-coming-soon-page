// =============================================================================
// 1. BLOOD REPORT UPLOAD API - /api/blood-report/upload
// =============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;
    const userId = formData.get('userId') as string;

    if (!file || !userId) {
      return NextResponse.json(
        { error: 'File and userId are required' },
        { status: 400 }
      );
    }

    // Validate file type
    if (file.type !== 'application/pdf') {
      return NextResponse.json(
        { error: 'Only PDF files are allowed' },
        { status: 400 }
      );
    }

    // Validate file size (10MB limit)
    if (file.size > 10 * 1024 * 1024) {
      return NextResponse.json(
        { error: 'File size must be less than 10MB' },
        { status: 400 }
      );
    }

    // Generate unique file ID
    const fileId = uuidv4();
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const fileName = `${userId}_${timestamp}_${fileId}.pdf`;

    // Create upload directory if it doesn't exist
    const uploadDir = path.join(process.cwd(), 'uploads', 'blood-reports');
    try {
      await mkdir(uploadDir, { recursive: true });
    } catch (error) {
      // Directory might already exist
    }

    // Save file to disk
    const filePath = path.join(uploadDir, fileName);
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    await writeFile(filePath, buffer);

    console.log(`📄 File uploaded: ${fileName} (${file.size} bytes)`);

    return NextResponse.json({
      success: true,
      fileId,
      fileName,
      filePath,
      fileSize: file.size,
      uploadedAt: new Date().toISOString()
    });

  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { error: 'File upload failed' },
      { status: 500 }
    );
  }
}

// =============================================================================
// 2. BLOOD REPORT PROCESSING API - /api/blood-report/process
// =============================================================================

import { NextRequest, NextResponse } from 'next/server';
import pdf2pic from 'pdf2pic';
import Tesseract from 'tesseract.js';
import path from 'path';
import fs from 'fs';

// Blood parameter mappings with variations
const PARAMETER_MAPPINGS = {
  rbc: {
    patterns: ['rbc', 'red blood cell', 'erythrocyte', 'red cell count'],
    displayName: 'RBC',
    unit: 'mill/mm³',
    normalRange: '4.5-5.9 million cells/mcL (men); 4.1-5.1 (women)'
  },
  hemoglobin: {
    patterns: ['hemoglobin', 'haemoglobin', 'hgb', 'hb'],
    displayName: 'Hemoglobin',
    unit: 'g/dL',
    normalRange: '13.5-17.5 g/dL (men); 12.0-15.5 (women)'
  },
  wbc: {
    patterns: ['wbc', 'white blood cell', 'leukocyte', 'white cell count'],
    displayName: 'WBC',
    unit: 'cells/mm³',
    normalRange: '4,500-11,000 cells/mcL'
  },
  platelets: {
    patterns: ['platelet', 'plt', 'thrombocyte'],
    displayName: 'Platelet Count',
    unit: '10³/µL',
    normalRange: '150,000-450,000 platelets/mcL'
  },
  hdl: {
    patterns: ['hdl', 'hdl cholesterol', 'high density lipoprotein'],
    displayName: 'HDL Cholesterol',
    unit: 'mg/dL',
    normalRange: '40 mg/dL or higher (men); 50 or higher (women)'
  },
  ldl: {
    patterns: ['ldl', 'ldl cholesterol', 'low density lipoprotein'],
    displayName: 'LDL Cholesterol',
    unit: 'mg/dL',
    normalRange: 'Less than 100 mg/dL'
  },
  total_cholesterol: {
    patterns: ['total cholesterol', 'cholesterol total', 'cholesterol'],
    displayName: 'Total Cholesterol',
    unit: 'mg/dL',
    normalRange: 'Less than 200 mg/dL'
  },
  triglycerides: {
    patterns: ['triglyceride', 'tg', 'triacylglycerol'],
    displayName: 'Triglycerides',
    unit: 'mg/dL',
    normalRange: 'Less than 150 mg/dL'
  },
  vitamin_b12: {
    patterns: ['vitamin b12', 'b12', 'cobalamin', 'cyanocobalamin'],
    displayName: 'Vitamin B12',
    unit: 'pg/mL',
    normalRange: '200-900 pg/mL'
  },
  vitamin_d: {
    patterns: ['vitamin d', '25-oh vitamin d', '25(oh)d', 'calcidiol'],
    displayName: 'Vitamin D',
    unit: 'ng/mL',
    normalRange: '20-50 ng/mL'
  },
  hba1c: {
    patterns: ['hba1c', 'a1c', 'glycated hemoglobin', 'glycosylated hemoglobin'],
    displayName: 'HbA1C',
    unit: '%',
    normalRange: 'Below 5.7%'
  },
  glucose: {
    patterns: ['glucose', 'blood sugar', 'blood glucose', 'fasting glucose'],
    displayName: 'Glucose (Random)',
    unit: 'mg/dL',
    normalRange: '70-140 mg/dL (random); 70-99 mg/dL (fasting)'
  },
  tsh: {
    patterns: ['tsh', 'thyroid stimulating hormone', 'thyrotropin'],
    displayName: 'TSH',
    unit: 'µIU/mL',
    normalRange: '0.4-4.0 µIU/mL'
  },
  creatinine: {
    patterns: ['creatinine', 'creat', 'cr'],
    displayName: 'Creatinine',
    unit: 'mg/dL',
    normalRange: '0.7-1.3 mg/dL (men); 0.6-1.1 mg/dL (women)'
  },
  uric_acid: {
    patterns: ['uric acid', 'urate', 'ua'],
    displayName: 'Uric Acid',
    unit: 'mg/dL',
    normalRange: '3.5-7.2 mg/dL (men); 2.5-6.0 mg/dL (women)'
  },
  calcium: {
    patterns: ['calcium', 'ca', 'serum calcium'],
    displayName: 'Calcium',
    unit: 'mg/dL',
    normalRange: '8.5-10.5 mg/dL'
  },
  sodium: {
    patterns: ['sodium', 'na', 'serum sodium'],
    displayName: 'Sodium',
    unit: 'mmol/L',
    normalRange: '135-145 mmol/L'
  },
  potassium: {
    patterns: ['potassium', 'k', 'serum potassium'],
    displayName: 'Potassium',
    unit: 'mmol/L',
    normalRange: '3.5-5.0 mmol/L'
  }
};

// Extract text from PDF using OCR
async function extractTextFromPDF(filePath: string): Promise<string> {
  try {
    console.log('🔍 Converting PDF to image...');
    
    // Convert PDF to image
    const convert = pdf2pic.fromPath(filePath, {
      density: 300,
      saveFilename: "temp",
      savePath: path.dirname(filePath),
      format: "png",
      width: 2048,
      height: 2048
    });

    const result = await convert(1, { responseType: "image" });
    const imagePath = result.path;

    console.log('👁️ Running OCR on image...');
    
    // Run OCR on the image
    const { data: { text } } = await Tesseract.recognize(imagePath, 'eng', {
      logger: m => console.log('OCR Progress:', m)
    });

    // Clean up temporary image file
    try {
      fs.unlinkSync(imagePath);
    } catch (error) {
      console.warn('Could not delete temporary image:', error);
    }

    console.log('✅ OCR completed, extracted text length:', text.length);
    return text;

  } catch (error) {
    console.error('OCR extraction error:', error);
    throw new Error('Failed to extract text from PDF');
  }
}

// Extract blood parameters from OCR text
function extractBloodParameters(ocrText: string): Record<string, any> {
  const extractedParams: Record<string, any> = {};
  const lines = ocrText.toLowerCase().split('\n');
  
  console.log('🔍 Analyzing text for blood parameters...');
  
  for (const [paramKey, paramConfig] of Object.entries(PARAMETER_MAPPINGS)) {
    for (const line of lines) {
      for (const pattern of paramConfig.patterns) {
        if (line.includes(pattern.toLowerCase())) {
          // Try to extract value from the same line or nearby lines
          const value = extractValueFromLine(line, lines, pattern);
          if (value) {
            extractedParams[paramKey] = {
              displayName: paramConfig.displayName,
              value: value.number,
              unit: value.unit || paramConfig.unit,
              confidence: value.confidence,
              normalRange: paramConfig.normalRange,
              status: determineStatus(value.number, paramKey),
              rawText: line.trim()
            };
            console.log(`✅ Found ${paramConfig.displayName}: ${value.number} ${value.unit}`);
            break;
          }
        }
      }
      if (extractedParams[paramKey]) break;
    }
  }
  
  console.log(`📊 Extracted ${Object.keys(extractedParams).length} parameters`);
  return extractedParams;
}

// Extract numeric value from text line
function extractValueFromLine(line: string, allLines: string[], pattern: string): any {
  // Common patterns for medical values
  const valuePatterns = [
    /(\d+\.?\d*)\s*(mg\/dl|g\/dl|mmol\/l|pg\/ml|ng\/ml|µiu\/ml|mill\/mm³|cells\/mm³|10³\/µl|%)/i,
    /(\d+,?\d*\.?\d*)\s*(mg\/dl|g\/dl|mmol\/l|pg\/ml|ng\/ml|µiu\/ml|mill\/mm³|cells\/mm³|10³\/µl|%)/i,
    /(\d+\.?\d*)/
  ];

  let bestMatch = null;
  let bestConfidence = 0;

  for (const regex of valuePatterns) {
    const match = line.match(regex);
    if (match) {
      const number = parseFloat(match[1].replace(',', ''));
      const unit = match[2] || '';
      
      // Calculate confidence based on various factors
      let confidence = 0.5;
      
      // Higher confidence if unit is present
      if (unit) confidence += 0.3;
      
      // Higher confidence if number is reasonable for medical values
      if (number > 0 && number < 10000) confidence += 0.2;
      
      // Higher confidence if the pattern is at the beginning of the line
      const patternIndex = line.toLowerCase().indexOf(pattern.toLowerCase());
      if (patternIndex >= 0 && patternIndex < 10) confidence += 0.2;

      if (confidence > bestConfidence) {
        bestMatch = { number, unit, confidence: Math.min(confidence, 1.0) };
        bestConfidence = confidence;
      }
    }
  }

  return bestMatch;
}

// Determine if a value is normal, high, or low
function determineStatus(value: number, paramKey: string): string {
  // Simple range checking - in production, this would be more sophisticated
  const ranges: Record<string, { low: number; high: number }> = {
    rbc: { low: 4.1, high: 5.9 },
    hemoglobin: { low: 12.0, high: 17.5 },
    wbc: { low: 4500, high: 11000 },
    platelets: { low: 150, high: 450 },
    hdl: { low: 40, high: 100 },
    ldl: { low: 0, high: 100 },
    total_cholesterol: { low: 0, high: 200 },
    triglycerides: { low: 0, high: 150 },
    hba1c: { low: 0, high: 5.7 },
    glucose: { low: 70, high: 140 },
    tsh: { low: 0.4, high: 4.0 },
    creatinine: { low: 0.6, high: 1.3 },
    calcium: { low: 8.5, high: 10.5 },
    sodium: { low: 135, high: 145 },
    potassium: { low: 3.5, high: 5.0 }
  };

  const range = ranges[paramKey];
  if (!range) return 'unknown';

  if (value < range.low) return 'low';
  if (value > range.high) return 'high';
  return 'normal';
}

export async function POST(request: NextRequest) {
  try {
    const { fileId, userId } = await request.json();

    if (!fileId || !userId) {
      return NextResponse.json(
        { error: 'FileId and userId are required' },
        { status: 400 }
      );
    }

    // Find the uploaded file
    const uploadDir = path.join(process.cwd(), 'uploads', 'blood-reports');
    const files = fs.readdirSync(uploadDir);
    const targetFile = files.find(file => file.includes(fileId));

    if (!targetFile) {
      return NextResponse.json(
        { error: 'File not found' },
        { status: 404 }
      );
    }

    const filePath = path.join(uploadDir, targetFile);
    console.log(`🔄 Processing file: ${targetFile}`);

    // Extract text from PDF
    const ocrText = await extractTextFromPDF(filePath);

    // Extract blood parameters
    const parameters = extractBloodParameters(ocrText);

    // Try to extract report date from OCR text
    const reportDate = extractReportDate(ocrText);

    const result = {
      reportId: fileId,
      userId,
      fileName: targetFile,
      processedAt: new Date().toISOString(),
      reportDate,
      parameters,
      ocrText: ocrText.substring(0, 1000), // First 1000 chars for debugging
      summary: {
        totalParameters: Object.keys(parameters).length,
        highConfidence: Object.values(parameters).filter((p: any) => p.confidence > 0.8).length,
        mediumConfidence: Object.values(parameters).filter((p: any) => p.confidence >= 0.5 && p.confidence <= 0.8).length,
        lowConfidence: Object.values(parameters).filter((p: any) => p.confidence < 0.5).length
      }
    };

    console.log('✅ Processing completed:', result.summary);

    return NextResponse.json(result);

  } catch (error) {
    console.error('Processing error:', error);
    return NextResponse.json(
      { error: 'File processing failed: ' + error.message },
      { status: 500 }
    );
  }
}

// Extract report date from OCR text
function extractReportDate(ocrText: string): string | null {
  const datePatterns = [
    /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,
    /(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/,
    /(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+(\d{4})/i
  ];

  const lines = ocrText.split('\n');
  
  for (const line of lines) {
    for (const pattern of datePatterns) {
      const match = line.match(pattern);
      if (match) {
        try {
          // Try to parse the date
          const dateStr = match[0];
          const date = new Date(dateStr);
          if (!isNaN(date.getTime())) {
            return date.toISOString();
          }
        } catch (error) {
          continue;
        }
      }
    }
  }
  
  return null;
}

// =============================================================================
// 3. BLOOD REPORT CONFIRMATION API - /api/blood-report/confirm
// =============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/firebaseConfig';
import { doc, setDoc, updateDoc, getDoc } from 'firebase/firestore';

export async function POST(request: NextRequest) {
  try {
    const { userId, reportId, parameters, reportDate } = await request.json();

    if (!userId || !reportId || !parameters) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    console.log(`💾 Saving blood parameters for user: ${userId}`);

    // Save to blood_markers collection
    const bloodMarkersRef = doc(db, 'blood_markers', userId);
    
    // Convert parameters to the format expected by BodyJam
    const normalizedMarkers: Record<string, number | string> = {};
    
    for (const [key, param] of Object.entries(parameters)) {
      normalizedMarkers[key] = (param as any).value;
    }

    const bloodMarkersData = {
      userId,
      markers: normalizedMarkers,
      lastUpdated: new Date().toISOString(),
      source: 'ai_extracted',
      reportDate: reportDate || new Date().toISOString(),
      reportId
    };

    await setDoc(bloodMarkersRef, bloodMarkersData, { merge: true });

    // Also save the full report data for historical tracking
    const reportRef = doc(db, 'blood_reports', `${userId}_${reportId}`);
    const reportData = {
      userId,
      reportId,
      uploadDate: new Date().toISOString(),
      reportDate: reportDate || new Date().toISOString(),
      parameters,
      status: 'confirmed',
      confirmedAt: new Date().toISOString()
    };

    await setDoc(reportRef, reportData);

    console.log('✅ Blood parameters saved successfully');

    return NextResponse.json({
      success: true,
      parameters: normalizedMarkers,
      savedAt: new Date().toISOString()
    });

  } catch (error) {
    console.error('Confirmation error:', error);
    return NextResponse.json(
      { error: 'Failed to save parameters: ' + error.message },
      { status: 500 }
    );
  }
}

// =============================================================================
// 4. BLOOD MARKERS RETRIEVAL API - /api/blood-markers/[userId]
// =============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/firebaseConfig';
import { doc, getDoc } from 'firebase/firestore';

export async function GET(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    const { userId } = params;

    if (!userId) {
      return NextResponse.json(
        { error: 'User ID is required' },
        { status: 400 }
      );
    }

    console.log(`📊 Fetching blood markers for user: ${userId}`);

    const bloodMarkersRef = doc(db, 'blood_markers', userId);
    const bloodMarkersDoc = await getDoc(bloodMarkersRef);

    if (!bloodMarkersDoc.exists()) {
      return NextResponse.json({
        markers: {},
        lastUpdated: null,
        message: 'No blood markers found'
      });
    }

    const data = bloodMarkersDoc.data();
    
    return NextResponse.json({
      markers: data.markers || {},
      lastUpdated: data.lastUpdated,
      source: data.source,
      reportDate: data.reportDate
    });

  } catch (error) {
    console.error('Retrieval error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch blood markers: ' + error.message },
      { status: 500 }
    );
  }
}
